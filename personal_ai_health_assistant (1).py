# -*- coding: utf-8 -*-
"""Personal_AI_Health_Assistant.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bXQ7yPTTxtLX9j55xllE34TSZme1OWDE
"""

import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
from sklearn.preprocessing import MinMaxScaler, StandardScaler
from sklearn.model_selection import train_test_split
from sklearn.pipeline import Pipeline
from sklearn.feature_extraction.text import TfidfVectorizer
from xgboost import XGBClassifier
from sklearn.metrics import classification_report

df = pd.read_csv("/content/drive/MyDrive/Colab Notebooks/chronic_conditions.csv")

df

df.info()

df.value_counts()

df.isnull()

from wordcloud import WordCloud
text = ' '.join(df['Description'].astype(str).tolist())
wordcloud = WordCloud(height = 400, width = 400, background_color = 'black').generate(text)
plt.figure(figsize=(10, 5))
plt.imshow(wordcloud, interpolation='bilinear')
plt.axis('off')  # Remove axes
plt.show()

from wordcloud import WordCloud
text = ' '.join(df['Symptoms'].astype(str).tolist())
wordcloud_ = WordCloud(height = 400, width = 400, background_color = 'black').generate(text)
plt.figure(figsize=(10, 5))
plt.imshow(wordcloud_, interpolation='bilinear')
plt.axis('off')  # Remove axes
plt.show()

print(text)

from transformers import BertTokenizer, BertModel
import torch
from tqdm import tqdm

tokenizer = BertTokenizer.from_pretrained("bert-base-uncased")
bert_model = BertModel.from_pretrained("bert-base-uncased")

df['Output'] = df[['Condition', 'Description']].values.tolist()

def encode_symptoms(symptom_text):
  embeddings = []
  for text in tqdm(symptom_text):
    inputs = tokenizer(text, return_tensors = "pt", truncation = True, padding = True, max_length = 128)
    with torch.no_grad():
      outputs = bert_model(**inputs)
    cls_embedding = outputs.last_hidden_state[:, 0, :].numpy()
    embeddings.append(cls_embedding)
  return np.array(embeddings).reshape(len(embeddings), -1)

from sklearn.preprocessing import MultiLabelBinarizer
mlb = MultiLabelBinarizer()
X = encode_symptoms(df['Symptoms'].tolist())
y = mlb.fit_transform(df['Output'])

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=100)

from sklearn.ensemble import RandomForestClassifier
from sklearn.multioutput import MultiOutputClassifier
from sklearn.metrics import classification_report

model = MultiOutputClassifier(RandomForestClassifier(n_estimators=200, random_state = 100))
model.fit(X_train, y_train)

predictions = model.predict(X_test)

print(predictions)

print(classification_report(y_test, predictions))

# # Predict for a new symptom input
# def get_health_info(symptom_input):
#     # Encode the symptom input using the same BERT tokenizer and model
#     input_embedding = encode_symptoms([symptom_input]) # Encode the input symptom

#     # Get predicted probabilities for each condition
#     predicted_probs = model.predict_proba(input_embedding)[0]

#     # Get the index of the condition with the highest probability
#     predicted_condition_index = np.argmax(predicted_probs)

#     # Get the actual condition label using the index and classes_ attribute of the MultiOutputClassifier
#     predicted_condition = mlb.classes_[predicted_condition_index]

#     # Get the description from your dataset (first match)
#     # Check if the predicted condition exists in the DataFrame
#     if predicted_condition in df['Condition'].values:
#         match = df[df['Condition'] == predicted_condition].iloc[0]
#         condition = match['Condition']
#         description = match['Description']
#     else:
#         # Handle the case where the predicted condition is not found
#         condition = "Unknown"
#         description = "Condition not found in the database."


#     # You can hardcode or generate tips based on the condition
#     suggestions_dict = {
#         "Diabetes": "Maintain a balanced diet, monitor blood sugar levels, and exercise regularly.",
#         "Asthma": "Avoid allergens, carry your inhaler, and stay indoors during high-pollen days.",
#         "Hypertension": "Reduce salt intake, manage stress, and exercise regularly.",
#         # Add more conditions here...
#     }

#     suggestions = suggestions_dict.get(condition, "Consult a healthcare professional for advice.")

#     return {
#         'condition': condition,
#         'description': description,
#         'suggestions': suggestions
#     }

# # Example usage
# symptom_input = "Headaches, shortness of breath, nosebleeds"
# result = get_health_info(symptom_input)

# print(result)
!pip install google-generativeai
import google.generativeai as genai
import numpy as np
import pandas as pd

# Gemini API setup
genai.configure(api_key="AIzaSyADgwUC7FhEvnA_BiO9VK78j1E7VSy4gQg")  # <- Replace with actual key
gemini_model = genai.GenerativeModel('gemini-1.5-flash')

def get_health_info(symptom_input):
    # Step 1: Encode symptoms
    input_embedding = encode_symptoms([symptom_input])
    if input_embedding is None or len(input_embedding) == 0:
        return {
            'condition': "Unknown",
            'description': "Symptom encoding failed.",
            'suggestions': "Consult a healthcare professional for advice."
        }

    try:
        predicted_probs = model.predict_proba(input_embedding)
    except Exception as e:
        print(f"Model prediction error: {e}")
        predicted_probs = None

    predicted_condition = "Unknown"
    highest_prob = 0

    if predicted_probs is not None:
        prob_values = predicted_probs[0][0]
        predicted_condition_index = np.argmax(prob_values)
        highest_prob = prob_values[predicted_condition_index]
        threshold = 0.3
        if highest_prob > threshold:
            predicted_condition = mlb.classes_[predicted_condition_index]

    # Try looking it up in the DataFrame
    df['Condition_clean'] = df['Condition'].str.strip().str.lower()
    condition_lower = predicted_condition.strip().lower()
    if condition_lower in df['Condition_clean'].values:
        match = df[df['Condition_clean'] == condition_lower].iloc[0]
        condition = match['Condition']
        description = match['Description']
    else:
        condition = "Unknown"
        description = ""

    # If condition still unknown → Ask Gemini to predict
    if condition == "Unknown":
        fallback_prompt = (
            f"You are a trusted medical assistant. A patient reports the following symptoms: '{symptom_input}'. "
            "Based on these symptoms, suggest the most likely medical condition. "
            "Provide a brief description of the condition, and 2–3 self-care or lifestyle suggestions. "
            "Only include medically sound information. Be clear, concise, and empathetic."
        )
        try:
            gemini_response = gemini_model.generate_content(fallback_prompt)
            response_text = gemini_response.text.strip()
            condition = "Predicted by Gemini"
            description = response_text
            suggestions = response_text
        except Exception as e:
            print(f"Gemini fallback error: {e}")
            description = "Unable to determine the condition at this time."
            suggestions = "Consult a healthcare professional for advice."
    else:
        # Condition was found → now ask Gemini for advice
        advice_prompt = (
            f"You are a medical assistant. A patient reported the following symptoms: '{symptom_input}'. "
            f"A condition '{condition}' has been predicted. "
            f"Give a short explanation of this condition, followed by 2–3 lifestyle or self-care suggestions."
        )
        try:
            gemini_response = gemini_model.generate_content(advice_prompt)
            suggestions = gemini_response.text.strip()
        except Exception as e:
            print(f"Gemini suggestion error: {e}")
            suggestions = "Unable to generate suggestions at the moment."

    # Debug info
    print(f"\n[DEBUG]")
    print(f"Input: {symptom_input}")
    print(f"Model-predicted Condition: {predicted_condition}")
    print(f"Final Condition: {condition}")
    print(f"Highest Probability: {highest_prob:.4f}")

    return {
        'condition': condition,
        'description': description,
        'suggestions': suggestions
    }

symptom_input = "pain in the shoulder"
result = get_health_info(symptom_input)
print(result)
print("CAUTION: I am an AI health assistant and I can make mistakes too!. Please do not get panic and if facing serious issues like pain or fatigue, immediately consult a doctor!")

